/**********************************************************************************************************************
 * \file ADC_Queued_Scan.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
*/


#include "ADC.h"
#include "MotorMgtSwc.h"
#include "IfxGtm_Tom_Timer.h"

IfxVadc_Adc vadc;

IfxVadc_Adc_Group adcGroup[6];

IfxVadc_Adc_Channel adcChannel[6][8];

uint16 ADC_result[6][8];
float Voltage[6][8];
float Vphase_Vpower,Vphase_U,Vphase_V,Vphase_W,Vcom_5V,Driver_5V,VDDA_12V,VDDB_12V,VPMIC_12V,CAN3_3V,HALL3_3V,VDD_detect;
float CurrentU_BUS,CurrentU_BUS_alter,CurrentV_BUS,CurrentV_BUS_alter,CurrentW_BUS,CurrentW_BUS_alter,
       CurrentU_analog,CurrentV_analog,CurrentW_analog;

//uint32 ADC_result[6][8];

void ADC_init(void)//config all of the channel
{
    int chnIx;
    int group_i=0;

    IfxVadc_Adc_Config adcConfig;
    IfxVadc_Adc_initModuleConfig(&adcConfig, &MODULE_VADC);

    adcConfig.startupCalibration=TRUE;
    adcConfig.globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
    adcConfig.globalInputClass[0].sampleTime = 1.0e-6;

    IfxVadc_Adc_initModule(&vadc, &adcConfig);

    IfxVadc_Adc_GroupConfig adcGroupConfig;
    IfxVadc_Adc_initGroupConfig(&adcGroupConfig, &vadc);

    for(group_i=0;group_i<6;group_i++)
    {
        // change group (default is GroupId_0)
        adcGroupConfig.groupId = group_i;
        // IMPORTANT: usually we use the same group as master!
        adcGroupConfig.master = adcGroupConfig.groupId;
        // enable all arbiter request sources
        // enable Queue mode
        adcGroupConfig.arbiter.requestSlotQueueEnabled          = TRUE;
        // enable Scan mode
        adcGroupConfig.arbiter.requestSlotScanEnabled           = TRUE;
        // enable Background scan
        adcGroupConfig.arbiter.requestSlotBackgroundScanEnabled = TRUE;
        // enable all gates in "always" mode (no edge detection)
        adcGroupConfig.queueRequest.triggerConfig.gatingMode          = IfxVadc_GatingMode_always;
        adcGroupConfig.scanRequest.triggerConfig.gatingMode           = IfxVadc_GatingMode_always;
        adcGroupConfig.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

        // initialize the group
        IfxVadc_Adc_initGroup(&adcGroup[group_i], &adcGroupConfig);
        IfxVadc_Adc_ChannelConfig adcChannelConfig[8];

        for(chnIx=0; chnIx<8; ++chnIx)
        {
            IfxVadc_Adc_initChannelConfig(&adcChannelConfig[chnIx], &adcGroup[group_i]);

            adcChannelConfig[chnIx].channelId = (IfxVadc_ChannelId)(chnIx);
            adcChannelConfig[chnIx].resultRegister = (IfxVadc_ChannelResult)(chnIx);
//            adcChannelConfig[chnIx].synchonize = TRUE;
            // initialize the channel
            adcChannelConfig[chnIx].resultServProvider = IfxSrc_Tos_cpu0;
            adcChannelConfig[chnIx].channelServProvider = IfxSrc_Tos_cpu0;
            IfxVadc_Adc_initChannel(&adcChannel[group_i][chnIx], &adcChannelConfig[chnIx]);

            unsigned channels = (1 << adcChannelConfig[chnIx].channelId);
            unsigned mask = channels;
            IfxVadc_Adc_setScan(&adcGroup[group_i], channels, mask);
        }
    }
}


void CurrentADC_init(void)// only config  the channel related to the current
{
    int chnIx;
    int group_i=4;

    IfxVadc_Adc_Config adcConfig;
    IfxVadc_Adc_initModuleConfig(&adcConfig, &MODULE_VADC);

    adcConfig.startupCalibration=TRUE;
    adcConfig.globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
    adcConfig.globalInputClass[0].sampleTime = 1.0e-6;

    IfxVadc_Adc_initModule(&vadc, &adcConfig);

    IfxVadc_Adc_GroupConfig adcGroupConfig;
    IfxVadc_Adc_initGroupConfig(&adcGroupConfig, &vadc);

//    for(group_i=0;group_i<6;group_i++)
    {
        // change group (default is GroupId_0)
        adcGroupConfig.groupId = group_i;
        // IMPORTANT: usually we use the same group as master!
        adcGroupConfig.master = adcGroupConfig.groupId;
        // enable all arbiter request sources
        // enable Queue mode
        adcGroupConfig.arbiter.requestSlotQueueEnabled          = TRUE;
        // enable Scan mode
        adcGroupConfig.arbiter.requestSlotScanEnabled           = TRUE;
        // enable Background scan
        adcGroupConfig.arbiter.requestSlotBackgroundScanEnabled = TRUE;
        // enable all gates in "always" mode (no edge detection)
        adcGroupConfig.queueRequest.triggerConfig.gatingMode          = IfxVadc_GatingMode_always;
        adcGroupConfig.scanRequest.triggerConfig.gatingMode           = IfxVadc_GatingMode_always;
        adcGroupConfig.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
        adcGroupConfig.scanRequest.requestSlotPrio = IfxVadc_RequestSlotPriority_low;
        adcGroupConfig.inputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
        adcGroupConfig.inputClass[0].sampleTime = 1.0e-6;
        // initialize the group
        IfxVadc_Adc_initGroup(&adcGroup[group_i], &adcGroupConfig);
        IfxVadc_Adc_ChannelConfig adcChannelConfig[8];

        for(chnIx=0; chnIx<8; ++chnIx)
        {
            IfxVadc_Adc_initChannelConfig(&adcChannelConfig[chnIx], &adcGroup[group_i]);

            adcChannelConfig[chnIx].channelId = (IfxVadc_ChannelId)(chnIx);
            adcChannelConfig[chnIx].resultRegister = (IfxVadc_ChannelResult)(chnIx);
            adcChannelConfig[chnIx].resultServProvider = IfxSrc_Tos_cpu0;
            adcChannelConfig[chnIx].channelServProvider = IfxSrc_Tos_cpu0;
//            adcChannelConfig[chnIx].synchonize = TRUE;
            // initialize the channel
            IfxVadc_Adc_initChannel(&adcChannel[group_i][chnIx], &adcChannelConfig[chnIx]);
            unsigned channels = (1 << adcChannelConfig[chnIx].channelId);
            unsigned mask = channels;
            IfxVadc_Adc_setScan(&adcGroup[group_i], channels, mask);
        }
    }
}

void SingleADC_Init(uint8 group_i,uint8 chnIx) /*only config  a single channel to the scan mode*/
{
    IfxVadc_Adc_Config adcConfig;
    IfxVadc_Adc_initModuleConfig(&adcConfig, &MODULE_VADC);

    adcConfig.startupCalibration=TRUE;
    adcConfig.globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
    adcConfig.globalInputClass[0].sampleTime = 1.0e-6;

    IfxVadc_Adc_initModule(&vadc, &adcConfig);

    IfxVadc_Adc_GroupConfig adcGroupConfig;
    IfxVadc_Adc_initGroupConfig(&adcGroupConfig, &vadc);


    {
        adcGroupConfig.groupId = group_i;
        adcGroupConfig.master = adcGroupConfig.groupId;
        adcGroupConfig.arbiter.requestSlotScanEnabled           = TRUE;
        adcGroupConfig.scanRequest.triggerConfig.gatingMode           = IfxVadc_GatingMode_always;
        IfxVadc_Adc_initGroup(&adcGroup[group_i], &adcGroupConfig);

    }

    {
        IfxVadc_Adc_ChannelConfig adcChannelConfig[8];
        IfxVadc_Adc_initChannelConfig(&adcChannelConfig[chnIx], &adcGroup[group_i]);

        adcChannelConfig[chnIx].channelId = (IfxVadc_ChannelId)(chnIx);
        adcChannelConfig[chnIx].resultRegister = (IfxVadc_ChannelResult)(chnIx);
        adcChannelConfig[chnIx].resultServProvider = IfxSrc_Tos_cpu0;
        adcChannelConfig[chnIx].channelServProvider = IfxSrc_Tos_cpu0;

        IfxVadc_Adc_initChannel(&adcChannel[group_i][chnIx], &adcChannelConfig[chnIx]);
        unsigned channels = (1 << adcChannelConfig[chnIx].channelId);
        unsigned mask = channels;
        IfxVadc_Adc_setScan(&adcGroup[group_i], channels, mask);
     }

}

void Multi_ADC_init(void)
{
     SingleADC_Init(2,4);//V voltage
     SingleADC_Init(2,5);//U voltage
     SingleADC_Init(3,1);//W voltage
     SingleADC_Init(TEMP_Group,TEMP_Channel);
     SingleADC_Init(VlotageBUS_Group,VlotageBUS_Channel);
}

void RegisterFiltering(void)
{
    /*setting the VADCG4.3 accumulate 4 result*/
    VADC_G4_RCR3.B.DMM = 0;
    VADC_G4_RCR3.B.DRCTR = 3;

    /*setting the VADCG4.6 accumulate 4 result*/
    VADC_G4_RCR6.B.DMM = 0;
    VADC_G4_RCR6.B.DRCTR = 3;

    /*setting the VADCG4.7 accumulate 4 result*/
    VADC_G4_RCR7.B.DMM = 0;
    VADC_G4_RCR7.B.DRCTR = 3;
}

void ADC_Scan(void)  //scan all of  the channel
{
unsigned int chnIx;
int group_m;

//    int group_current = 4;
//    int channel_UVW[] = {3,6,7};


Ifx_VADC_RES conversionResult;

for(group_m=0;group_m<6;group_m++)
{
    IfxVadc_Adc_startScan(&adcGroup[group_m]);

    for(chnIx=0;chnIx<8;++chnIx)
    {

        do{
            conversionResult = IfxVadc_Adc_getResult(&adcChannel[group_m][chnIx]);
          } while( !conversionResult.B.VF );

        ADC_result[group_m][chnIx] = conversionResult.B.RESULT;
     }
}
}

void CurrentScan(void)//only scan  the channel related to the current
{
int group_current = 4;
int channel_UVW[] = {3,6,7};


Ifx_VADC_RES conversionResult;

IfxVadc_Adc_startScan(&adcGroup[group_current]);//scan group4
  for(int k=0;k<3;k++)
  {

    do{
        conversionResult = IfxVadc_Adc_getResult(&adcChannel[group_current][channel_UVW[k]]);
      } while( !conversionResult.B.VF );

    ADC_result[group_current][channel_UVW[k]] = conversionResult.B.RESULT;
   }

}

void Temp_Voltage_DetectScan(void)
{
    Ifx_VADC_RES conversionResult;

    IfxVadc_Adc_startScan(&adcGroup[3]);

     do{
           conversionResult = IfxVadc_Adc_getResult(&adcChannel[3][5]);
       } while( !conversionResult.B.VF );

     ADC_result[3][5] = conversionResult.B.RESULT;

     do{
           conversionResult = IfxVadc_Adc_getResult(&adcChannel[3][2]);
       } while( !conversionResult.B.VF );

     ADC_result[3][2] = conversionResult.B.RESULT;

     do{
           conversionResult = IfxVadc_Adc_getResult(&adcChannel[3][1]);
       } while( !conversionResult.B.VF );

     ADC_result[3][1] = conversionResult.B.RESULT;


     IfxVadc_Adc_startScan(&adcGroup[2]);
     do{
           conversionResult = IfxVadc_Adc_getResult(&adcChannel[2][4]);
       } while( !conversionResult.B.VF );

     ADC_result[2][4] = conversionResult.B.RESULT;
     do{
           conversionResult = IfxVadc_Adc_getResult(&adcChannel[2][5]);
       } while( !conversionResult.B.VF );

     ADC_result[2][5] = conversionResult.B.RESULT;

     Vphase_Vpower = ADC_result[3][2]*Factor_phase_Vpower*Factor_DAC;
     g_bldc.Voltage_BUS = (uint8)Vphase_Vpower;
     Vphase_U = ADC_result[2][5]*Factor_phase_Vpower*Factor_DAC;
     Vphase_V = ADC_result[2][4]*Factor_phase_Vpower*Factor_DAC;
     Vphase_W = ADC_result[3][1]*Factor_phase_Vpower*Factor_DAC;
}


uint16 OLD_CURRENT_result[3] = {0};
void Current_filtering(void)// get Voltage_BUS and the filtering Current
{
    int group_current = 4;
    int channel_UVW[] = {3,6,7};
    float alpha_current = 0.2;

    float Factor_IBUS_phase = 2160.0/22.0;

    uint16 NEW_CURRENT_result[3];

    float Current_BUS[3];

    Vphase_Vpower = ADC_result[3][2]*Factor_phase_Vpower*Factor_DAC;
    g_bldc.Voltage_BUS = 5*Vphase_Vpower;


  for(int k =0;k<3;k++)
  {
    NEW_CURRENT_result[k] = alpha_current*ADC_result[group_current][channel_UVW[k]]
                                                             +(1-alpha_current)*OLD_CURRENT_result[k];

    Current_BUS[k] = NEW_CURRENT_result[k]*Factor_IBUS_phase*Factor_DAC;

    OLD_CURRENT_result[k] = NEW_CURRENT_result[k];

  }
  g_bldc.CurrentU_BUS = 100*Current_BUS[0];
  g_bldc.CurrentW_BUS = 100*Current_BUS[1];
  g_bldc.CurrentV_BUS = 100*Current_BUS[2];
}


void DAC_Scan(void) //get all of the analog
{


//   float Factor_Drive5V_Vcom = 2.0;
//   float Factor_VDD_VPMIC = 4.0;
//   float Factor_3_3V = 1.0;

   float Factor_IBUS_phase = 2160.0/22.0;



   Vphase_Vpower = ADC_result[3][2]*Factor_phase_Vpower*Factor_DAC;
//   Vphase_U = ADC_result[2][5]*Factor_phase_Vpower*Factor_DAC;
//   Vphase_V = ADC_result[2][4]*Factor_phase_Vpower*Factor_DAC;
//   Vphase_W = ADC_result[3][1]*Factor_phase_Vpower*Factor_DAC;
//
//   Driver_5V = ADC_result[3][0]*Factor_Drive5V_Vcom*Factor_DAC;
//   Vcom_5V = ADC_result[5][5]*Factor_Drive5V_Vcom*Factor_DAC;
//
//   VDDA_12V = ADC_result[3][4]*Factor_VDD_VPMIC*Factor_DAC;
//   VDDB_12V = ADC_result[3][3]*Factor_VDD_VPMIC*Factor_DAC;
//   VPMIC_12V = ADC_result[2][3]*Factor_VDD_VPMIC*Factor_DAC;
//
//   CAN3_3V = ADC_result[5][4]*Factor_3_3V*Factor_DAC;
//   HALL3_3V = ADC_result[2][2]*Factor_3_3V*Factor_DAC;
//   VDD_detect = ADC_result[5][7]*Factor_3_3V*Factor_DAC;

//   Current_filtering();



   CurrentU_BUS = ADC_result[4][3]*Factor_IBUS_phase*Factor_DAC;
//   IBUS_U_alter = ADC_result[4][1]*Factor_IBUS_phase*Factor_DAC;

   CurrentV_BUS = ADC_result[4][7]*Factor_IBUS_phase*Factor_DAC;
//   IBUS_V_alter = ADC_result[4][4]*Factor_IBUS_phase*Factor_DAC;

   CurrentW_BUS = ADC_result[4][6]*Factor_IBUS_phase*Factor_DAC;
//   IBUS_W_alter = ADC_result[4][5]*Factor_IBUS_phase*Factor_DAC;


   g_bldc.CurrentU_BUS = 100*CurrentU_BUS;
   g_bldc.CurrentV_BUS = 100*CurrentV_BUS;
   g_bldc.CurrentW_BUS = 100*CurrentW_BUS;

   g_bldc.Voltage_BUS = 5*Vphase_Vpower;
}

//#define ISR_PRIORITY_TOM    1
//#define TOM_DealFREQ            20000.0f
//IfxGtm_Tom_Timer g_timerDriver;
//
//IFX_INTERRUPT(interruptGtmTom_currentADC, 0, ISR_PRIORITY_TOM);
//
///* Interrupt Service Routine of the TOM */
//void interruptGtmTom_currentADC(void)
//{
//    IfxGtm_Tom_Timer_acknowledgeTimerIrq(&g_timerDriver);
//    ADC_Scan();
////  CurrentScan();
//    Current_filtering();
//}
//
//
//void initGtmTom_currentADC(void)
//{
//    IfxGtm_enable(&MODULE_GTM);
//
//    IfxGtm_Tom_Timer_Config timerConfig;
//    IfxGtm_Tom_Timer_initConfig(&timerConfig, &MODULE_GTM);
//
//    timerConfig.base.frequency       = TOM_DealFREQ;
//    timerConfig.base.isrPriority     = ISR_PRIORITY_TOM;
//    timerConfig.base.isrProvider     = IfxSrc_Tos_cpu0;
//    timerConfig.tom                  = IfxGtm_Tom_1;
//    timerConfig.timerChannel         = IfxGtm_Tom_Ch_0;
//    timerConfig.clock                = IfxGtm_Tom_Ch_ClkSrc_cmuFxclk3;
//
//    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_FXCLK);
//    IfxGtm_Tom_Timer_init(&g_timerDriver, &timerConfig);
//    IfxGtm_Tom_Timer_run(&g_timerDriver);
//}







