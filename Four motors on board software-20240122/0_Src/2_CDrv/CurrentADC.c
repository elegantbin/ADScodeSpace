/**********************************************************************************************************************
 * \file ADC_Queued_Scan.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
*/


#include "ADC.h"
#include "MotorMgtSwc.h"
#include "IfxGtm_Tom_Timer.h"
#include <EncoderGpt12.h>
#include "CurrentADC.h"
#include "CommutationControl.h"
#include"Ifxvadc.h"
#include "BackgroundADC.h"


#define ISR_PRIORITY_TOM    20

/* Interrupt Service Routine of the TOM */
int group_I = 4;
int Chn_I[3] = {3,6,7};
int num_chn;
static uint16 PhaseCurrent[3]={2250,2250,2250};
float32 Current_Analog[3] = {323.0,317.0,322.0};
float SUM_PhaseCurrent[3];
uint16 NEW_current_result[3];
static uint16 OLD_current_result[3] ={2250,2250,2250};

uint8 current_count[3] = {0};


Ifx_VADC_RES conversionResult;

IfxGtm_Tom_Timer g_timerDriver;
IfxGtm_Tom_Timer_Config timerConfig;


IFX_INTERRUPT(interruptGtmTom_currentADC, 2, ISR_PRIORITY_TOM);

#define ADCMODE        (2)

#define SCAN           (1)
#define BackgroundScan (2)
void interruptGtmTom_currentADC(void)
{
    /*While entering the interrupt ,triggering the pin state to change*/
    IfxPort_setPinMode(&MODULE_P32, 4,  IfxPort_Mode_outputPushPullGeneral);
    IfxPort_togglePin(&MODULE_P32, 4);
    /*clear the timer*/
    IfxGtm_Tom_Timer_acknowledgeTimerIrq(&g_timerDriver);

#if(ADCMODE == SCAN)
    IfxVadc_Adc_startScan(&adcGroup[group_I]);  /*scan group4*/
    do{
    conversionResult = IfxVadc_Adc_getResult(&adcChannel[group_I][Chn_I[num_chn]]);
    }while(conversionResult.B.DRC != 0);
    ADC_result[group_I][Chn_I[num_chn]] = conversionResult.B.RESULT;

    IfxVadc_Adc_stopScan(&adcGroup[group_I]);   /*Added by author to the iLLD to stop the scan*/

#elif(ADCMODE == BackgroundScan)
    IfxVadc_Adc_startBackgroundScan(&g_vadc);  /*start BackgroundScan*/

    ADC_result[group_I][Chn_I[num_chn]] = (uint16)readADCValue(num_chn);

    IfxVadc_Adc_stopBackgroundScan(&g_vadc);  /*Added by author to the iLLD to stop the scan*/
#endif

    MODULE_GTM.CMU.CLK_EN.U = IFXGTM_CMU_CLKDIS_FXCLK;  /*disable FXCLK*/

    PhaseCurrent_Calculate(num_chn);  /*the relevant calculate about current filtering*/
    g_bldc.CurrentU_BUS = Current_Analog[0]- Avg_current_offset[0];
    g_bldc.CurrentW_BUS = Current_Analog[1]- Avg_current_offset[1];
    g_bldc.CurrentV_BUS = Current_Analog[2]- Avg_current_offset[2];
//    Current_updateDuty();

#if(swithstep)
    switch(g_PosCtrlStep%6)
    {

           case HIGH_V_PWM_LOW_U_ON:
//               PhaseCurrent[2]  =  PhaseCurrent[num_channel];
//               PhaseCurrent[1]  =  0;
               g_bldc.CurrentU_BUS = PhaseCurrent[0];
               g_bldc.CurrentV_BUS = PhaseCurrent[2];
               g_bldc.CurrentW_BUS = PhaseCurrent[1];


               break;

           case HIGH_V_PWM_LOW_W_ON:
//               PhaseCurrent[2]  =  PhaseCurrent[num_channel];
//               PhaseCurrent[0]  =  268.134;
               g_bldc.CurrentU_BUS = PhaseCurrent[0];
               g_bldc.CurrentV_BUS = PhaseCurrent[2];
               g_bldc.CurrentW_BUS = PhaseCurrent[1];

               break;

           case HIGH_U_PWM_LOW_W_ON:
//               PhaseCurrent[0]  =  PhaseCurrent[num_channel];
//               PhaseCurrent[2]  =  268.723;
               g_bldc.CurrentU_BUS = PhaseCurrent[0];
               g_bldc.CurrentV_BUS = PhaseCurrent[2];
               g_bldc.CurrentW_BUS = PhaseCurrent[1];
               break;

           case HIGH_U_PWM_LOW_V_ON:
//               PhaseCurrent[0]  =  PhaseCurrent[num_channel];
//               PhaseCurrent[1]  =  269.9994;
               g_bldc.CurrentU_BUS = PhaseCurrent[0];
               g_bldc.CurrentV_BUS = PhaseCurrent[2];
               g_bldc.CurrentW_BUS = PhaseCurrent[1];
               break;

           case HIGH_W_PWM_LOW_V_ON:
//               PhaseCurrent[1]  =  PhaseCurrent[num_channel];
//               PhaseCurrent[0]  =  268.134;
               g_bldc.CurrentU_BUS = PhaseCurrent[0];
               g_bldc.CurrentV_BUS = PhaseCurrent[2];
               g_bldc.CurrentW_BUS = PhaseCurrent[1];
               break;

           case HIGH_W_PWM_LOW_U_ON:
//               PhaseCurrent[1]  =  PhaseCurrent[num_channel];
//               PhaseCurrent[2]  =  268.723;
               g_bldc.CurrentU_BUS = PhaseCurrent[0];
               g_bldc.CurrentV_BUS = PhaseCurrent[2];
               g_bldc.CurrentW_BUS = PhaseCurrent[1];
               break;

           default:/* Error status*/

               break;
       }
#endif
}

void initGtmTom_currentADC(void)
{
    IfxGtm_enable(&MODULE_GTM);
    IfxGtm_Tom_Timer_initConfig(&timerConfig, &MODULE_GTM);

    timerConfig.base.isrPriority     = ISR_PRIORITY_TOM;
    timerConfig.base.isrProvider     = IfxSrc_Tos_cpu2;
    timerConfig.tom                  = IfxGtm_Tom_1;
    timerConfig.timerChannel         = IfxGtm_Tom_Ch_0;
    timerConfig.clock                = IfxGtm_Tom_Ch_ClkSrc_cmuFxclk2;

    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_FXCLK);
    IfxGtm_Tom_Timer_init(&g_timerDriver, &timerConfig);
}

void initGtmTom_currentADC_Freq(void)
{
    float32 TOM_ADC_FREQ= g_absMotSpeed/0.6;  /* the time of communication is 2/absMotSpeed */
    timerConfig.base.frequency       = TOM_ADC_FREQ;
    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_FXCLK);
    IfxGtm_Tom_Timer_init(&g_timerDriver, &timerConfig);
    IfxGtm_Tom_Timer_run(&g_timerDriver);
}

float Real_PhaseCurrent[3];

#define FilteringMode                  (LowPassFiltering)

#define NoFiltering                    (0)
#define LowPassFiltering               (1)
#define AverageFilteringMode1          (2)
#define LowPass_AverageFilteringMode   (3)
#define SlopeFiltering                 (4)

void PhaseCurrent_Calculate(int nchannel)
{

#if(LowPassFiltering==FilteringMode)
      float beta_current = 0.1;

      NEW_current_result[nchannel] =
                 beta_current *ADC_result[group_I][Chn_I[nchannel]]+(1-beta_current)*OLD_current_result[nchannel];

      OLD_current_result[nchannel] = NEW_current_result[nchannel];

      Current_Analog[nchannel]=(float)(NEW_current_result[nchannel]*VOLT_CONVERSION*RESISTANCE_VALUE/VOLT_GAIN);


#elif(NoFiltering==FilteringMode)
      /*************************original Current**********************/

     Current_Analog[nchannel]=(float)(ADC_result[group_I][Chn_I[nchannel]]*VOLT_CONVERSION*RESISTANCE_VALUE/VOLT_GAIN);

#elif(SlopeFiltering==FilteringMode)
    uint16  b[3];
    float32 T;
    float32 m[3];
    static uint8 K=5;
    static uint16 a[3]={2250,2250,2250};
    uint8 i;

    b[nchannel] = ADC_result[group_I][Chn_I[nchannel]];
    T= (float32)2000.0/g_absMotSpeed;      //Unit:Ms
    m[nchannel] = (b[nchannel]-a[nchannel])/T;
    if(m[nchannel]>0)
    {
        i=1;
    }
    else
    {
        i=-1;
    }
    if((m[nchannel]>(K))&&(m[nchannel]<(-K)))
    {
        b[nchannel] = (uint16)(i*K*T+a[nchannel]);
    }
    else
    {

    }
    PhaseCurrent[nchannel] = b[nchannel];
    a[nchannel]=b[nchannel];


#elif(AverageFilteringMode1==FilteringMode)
    /*************************average filtering*******************/
    Real_PhaseCurrent[nchannel] =  ADC_result[group_I][Chn_I[nchannel]];
    current_count[nchannel]++;

    if((Real_PhaseCurrent[nchannel] -PhaseCurrent[nchannel] > 100) || (Real_PhaseCurrent[nchannel]-PhaseCurrent[nchannel] < -100))
    {
        Real_PhaseCurrent[nchannel]  = PhaseCurrent[nchannel];
    }

    SUM_PhaseCurrent[nchannel] += Real_PhaseCurrent[nchannel];
    if(current_count[nchannel] == 4)
    {
    PhaseCurrent[nchannel] = SUM_PhaseCurrent[nchannel]/current_count[nchannel];
    current_count[nchannel] = 0;
    SUM_PhaseCurrent[nchannel] =0;
    }
#elif(LowPass_AverageFilteringMode==FilteringMode)
    {

        float beta_current = 0.04;

        NEW_current_result[Chn_I[nchannel]] =
                    beta_current *ADC_result[group_I][Chn_I[nchannel]]+(1-beta_current)*OLD_current_result[Chn_I[nchannel]];

        PhaseCurrent[nchannel]= NEW_current_result[Chn_I[nchannel]];

        OLD_current_result[Chn_I[nchannel]] = NEW_current_result[Chn_I[nchannel]];

        static uint16 current_filter_array[3][10]={{0}};

        uint32 current_sum [3]= {0};
        for(uint8 k=0;k<9;k++)
        {
           current_filter_array[nchannel][k]=current_filter_array[nchannel][k+1];
        }
        current_filter_array[nchannel][9]= PhaseCurrent[nchannel];

        for(uint8 i=0;i<10;i++)
        {
            current_sum[nchannel]+=current_filter_array[nchannel][i];
        }
        PhaseCurrent[nchannel] = (uint16)(current_sum[nchannel]/10);
    }
#endif
}


void GtmTomCurrent_6Step(enComutateDriverIndex step)
{
    switch(step){
        case HIGH_V_PWM_LOW_U_ON:
            num_chn = 0;
            initGtmTom_currentADC_Freq();
            break;

        case HIGH_V_PWM_LOW_W_ON:
            num_chn = 1;
            initGtmTom_currentADC_Freq();
            break;

        case HIGH_U_PWM_LOW_W_ON:
            num_chn = 1;
            initGtmTom_currentADC_Freq();

            break;

        case HIGH_U_PWM_LOW_V_ON:
            num_chn = 2;
            initGtmTom_currentADC_Freq();

            break;

        case HIGH_W_PWM_LOW_V_ON:

            num_chn = 2;
            initGtmTom_currentADC_Freq();

            break;

        case HIGH_W_PWM_LOW_U_ON:

            num_chn = 0;
            initGtmTom_currentADC_Freq();

            break;

        default:/* Error status*/

            break;
    }
}

#define offset_detect   (1)
#if(offset_detect)

#define CURRENT_OFFSET_TIMES       50             /* the sampling times when the motor stops*/

float32 Avg_current_offset[3]={323.0,317.0,322.0};
void CurrentOffsetDetect(void)
{
  static uint8 current_offset_p = 0;
  uint8 i =0;
  uint32 avg[3] = {0,0,0};
  static uint16 current_offset[3][CURRENT_OFFSET_TIMES] = {{0}};

  if(g_bldc.state ==  MOTOR_STATE_STOP)
  {
      IfxVadc_Adc_startBackgroundScan(&g_vadc);                 /*start BackgroundScan*/

      for(uint8 k=0;k<3;k++)
      {
          PhaseCurrent[k] = readADCValue(k);                    /*Current offset*/
      }

      IfxVadc_Adc_stopBackgroundScan(&g_vadc);  /*Added by author to the iLLD to stop the scan*/

      current_offset[0][current_offset_p] = PhaseCurrent[0];    /* get the three phase current when the motor is stop */
      current_offset[1][current_offset_p] = PhaseCurrent[1];
      current_offset[2][current_offset_p] = PhaseCurrent[2];

      current_offset_p ++;

      if (current_offset_p >= 50)
      {
          current_offset_p = 0;

          for(i=0; i<CURRENT_OFFSET_TIMES; i++)
          {
             avg[0] += current_offset[0][i];                     /* accumulate the 50 current value */
             avg[1] += current_offset[1][i];
             avg[2] += current_offset[2][i];
          }
          for(i=0; i<3; i++)
          {
             /* calculate the average current value */
             Avg_current_offset[i] = (float32)(avg[i]/CURRENT_OFFSET_TIMES*VOLT_CONVERSION*RESISTANCE_VALUE/VOLT_GAIN);
          }

       }

   }
}
#endif








