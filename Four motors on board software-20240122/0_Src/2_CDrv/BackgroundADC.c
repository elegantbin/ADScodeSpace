/**********************************************************************************************************************
 * \file ADC_Filtering.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include <BackgroundADC.h>

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* ADC parameters */
#define CHANNELS_NUM                3       /* Number of used channels                                              */

#define DMM_DATA_REDUCTION          0x0     /* Value of DMM bit field to set Standard Data Reduction Mode           */
#define DMM_RESULT_FILTERING        0x1     /* Value of DMM bit field to set Result Filtering Mode                  */
#define DRCTR_DATA_REDUCTION        0x3     /* Value of DRCTR to accumulate 4 conversions                           */
#define DRCTR_FIR_COEFF             0x4     /* Value of DRCTR to apply a FIR filter with coefficients a=1, b=0, c=2 */
#define DRCTR_IIR_COEFF             0xF     /* Value of DRCTR to apply a IIR filter with coefficients a=3, b=4      */

/* Possible values for FIR/IIR filter coefficients:
 * --------------------------------------------------------------------------------------------------------
 * |          Average filter          | * |          FIR filter         | * |         IIR filter          |
 * ------------------------------------ * ------------------------------- * -------------------------------
 * | DMM | DRCTR | Accumulated values | * | DMM | DRCTR | COEFFICIENTS  | * | DMM | DRCTR | COEFFICIENTS  |
 * ------------------------------------ * ------------------------------- * -------------------------------
 * | 0x0 |  0x0  | Disabled           | * | 0x1 |  0x0  | a=2, b=1, c=0 | * | 0x1 |  0xE  | a=2, b=2      |
 * | 0x0 |  0x1  | 2 results average  | * | 0x1 |  0x1  | a=1, b=2, c=0 | * |>0x1 |  0xF  | a=3, b=4      |
 * | 0x0 |  0x2  | 3 results average  | * | 0x1 |  0x2  | a=2, b=0, c=1 | * |     |       |               |
 * |>0x0 |  0x3  | 4 results average  | * | 0x1 |  0x3  | a=1, b=1, c=1 | * |     |       |               |
 * |     |       |                    | * |>0x1 |  0x4  | a=1, b=0, c=2 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0x5  | a=3, b=1, c=0 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0x6  | a=2, b=2, c=0 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0x7  | a=1, b=3, c=0 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0x8  | a=3, b=0, c=1 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0x9  | a=2, b=1, c=1 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0xA  | a=1, b=2, c=1 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0xB  | a=2, b=0, c=2 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0xC  | a=1, b=1, c=2 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0xD  | a=1, b=0, c=3 | * |     |       |               |
 * --------------------------------------------------------------------------------------------------------
 *
 * When selecting different coefficients, make sure to set the correct DIV_FACTOR.
 */


/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void initVADCModule(void);                  /* Function to initialize the VADC module with default parameters       */
void initVADCGroup(void);                   /* Function to initialize the VADC group                                */
void initVADCChannels(void);                /* Function to initialize the VADC used channels                        */
void OverSamplingInit(void);                  /* Function to apply the filters to the VADC channels                   */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/* Variables for the VADC */
IfxVadc_Adc g_vadc;                                     /* Global variable for configuring the VADC module          */
IfxVadc_Adc_Group g_vadcGroup;                          /* Global variable  for configuring the VADC group          */
IfxVadc_Adc_Channel g_vadcChannel[CHANNELS_NUM];        /* Global array for configuring the VADC channels           */

channel g_chn[] = { {&IfxVadc_G4_3_AN35_IN, (IfxVadc_ChannelResult) 15 },   /* AN35 pin    (IIR filter channel)       */
                    {&IfxVadc_G4_6_AN38_IN, (IfxVadc_ChannelResult) 7  },   /* AN38 pin    (FIR filter channel)       */
                    {&IfxVadc_G4_7_AN39_IN, (IfxVadc_ChannelResult) 0  },   /* AN39 pin    (Average filter channel)   */
                  };


/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Function to initialize the VADC module */
void InitCurrentADC_BCMode(void)
{
    initVADCModule();                                                   /* Initialize the VADC module               */
    initVADCGroup();                                                    /* Initialize the VADC group                 */
    initVADCChannels();                                                 /* Initialize the used channels             */
    OverSamplingInit();                                                 /* Configure the Data Modification registers*/
}

/* Function to initialize the VADC module with default parameters */
void initVADCModule(void)
{
    IfxVadc_Adc_Config adcConf;                                         /* Define a configuration structure         */
    IfxVadc_Adc_initModuleConfig(&adcConf, &MODULE_VADC);               /* Fill it with default values              */
    IfxVadc_Adc_initModule(&g_vadc, &adcConf);                          /* Apply the default configuration          */
}

/* Function to initialize the VADC group */
void initVADCGroup(void)
{
    /* Initialize the groups */
    IfxVadc_Adc_GroupConfig adcGroupConf;                               /* Define a configuration structure         */
    IfxVadc_Adc_initGroupConfig(&adcGroupConf, &g_vadc);                /* Fill it with default values              */

    /* Enable the background scan source and the background auto scan functionality */
    adcGroupConf.arbiter.requestSlotBackgroundScanEnabled = TRUE;
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    /* Set the group 4 as master group */
    adcGroupConf.master = IfxVadc_GroupId_4;
    adcGroupConf.groupId = IfxVadc_GroupId_4;

    /* Apply the configuration to the group, with group 4 as a master:                                          */
    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);
}

/* Function to initialize the used VADC channels */
void initVADCChannels(void)
{
    IfxVadc_Adc_ChannelConfig adcChannelConf;                   /* Configuration structure                          */

    uint16 chnNum;
    for(chnNum = 0; chnNum < CHANNELS_NUM; chnNum++)            /* The channels included in g_chn are initialized   */
    {
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf, &g_vadcGroup);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf.channelId = g_chn[chnNum].analogInput->channelId;
        adcChannelConf.resultRegister = g_chn[chnNum].resultRegister;
        adcChannelConf.backgroundChannel = TRUE;                /* Enable the background scan for the channel       */

        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chnNum], &adcChannelConf);

        /* Add the channel to the background scan:
         * Set the the corresponding input channel of the respective group to be added in the background scan sequence
         */
        unsigned chnEnableBit = (1 << adcChannelConf.channelId);
        unsigned mask = chnEnableBit;
        IfxVadc_Adc_setBackgroundScan(&g_vadc, &g_vadcGroup, chnEnableBit, mask);
    }
}

/* Function to apply the filters to the VADC channels */
void OverSamplingInit(void)
{
    /* Accumulate 4 result values within the result register before generating a final result */
    VADC_G4_RCR0.B.DMM = DMM_DATA_REDUCTION;        /* Set the Data Modification Mode bit field to Standard Data Reduction */
    VADC_G4_RCR0.B.DRCTR = DRCTR_DATA_REDUCTION;    /* Configure the Result Register 0 of Group 4 (AN39_G4C7) to accumulate 4 conversions */

    VADC_G4_RCR7.B.DMM = DMM_DATA_REDUCTION;
    VADC_G4_RCR7.B.DRCTR = DRCTR_DATA_REDUCTION;    /* Configure the Result Register 7 of Group 4 (AN38_G4C6) to accumulate 4 conversions */


    VADC_G4_RCR15.B.DMM = DMM_DATA_REDUCTION;
    VADC_G4_RCR15.B.DRCTR = DRCTR_DATA_REDUCTION;   /* Configure the Result Register 15 of Group 4 (AN35_G4C3) to accumulate 4 conversions */

}

/* Function to read the VADC measurements */
uint16 BC_current_AD;
uint16 readADCValue(uint8 channel)
{
    Ifx_VADC_RES conversionResult;                                      /* Variable to store the conversion result  */
    conversionResult.U = 0;                                             /* Initialize the value to 0                */

    /* Read ADC conversion until a valid one is read.
     * Since the AN39 pin is using the Standard Data Reduction mode, it is needed to check both the Valid Flag (VF == 1)
     * and the Data Reduction Counter (DRC == 0) bit fields to be sure that the read measurement is correct.
     */
    while(conversionResult.B.VF != 1 || conversionResult.B.DRC != 0)
    {
        conversionResult = IfxVadc_Adc_getResult(&g_vadcChannel[channel]);
    }

    BC_current_AD  = conversionResult.B.RESULT/DIV_FACTOR_AVRG;

    return BC_current_AD;
}
