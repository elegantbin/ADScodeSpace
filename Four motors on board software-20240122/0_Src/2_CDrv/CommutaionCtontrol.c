/**********************************************************************************************************************
 * \file GTM_ATOM_PWM.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include <GTM_ATOM_PWM_6Step.h>
#include "IfxGtm_Atom_Pwm.h"
#include "IfxPort.h"
#include "CommutationPoint.h"
#include "CommutationControl.h"
#include "ADC.h"
#include "MotorMgtSwc.h"
#include <EncoderGpt12.h>
#include <TempDetect.h>
#include"VelocityPI.h"
#include "FuzzyPID.h"
#include"CurrentPI.h"
#include "dutylimit.h"
#include "DutyStartupCurve.h"
#include "AppTaskFu.h"
#include "MULTICAN.h"
#include "MULTICAN_FD.h"
#include "SPI_ENCODER.h"
#include "PositionControl.h"
#include "TorqueControl.h"
#include "stdlib.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/


/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------Function Prototypes-------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------Function Implementations-----------------------------------------------*/
/*********************************************************************************************************************/

#define K_CONFIG_DELAY_TIME    (5)
#define K_STARTUP_PERIOD        (2000)
uint32 timeTestTicks=K_CONFIG_DELAY_TIME;  /*1ms task*/

uint32 g_MotStartTimer = 0;

uint8  g_PosCtrlStep=0;
uint8 theOld_PosCtrlStep=0;
volatile uint8  b_ZeroDetected =0;
uint16 u8DrvDuty_Speed;
volatile uint16 u8DrvDuty_Current = 0;
uint16 u8DrvDuty_Positon;

volatile uint16 u8DrvDuty = K_MOTOR_DRVPWM_DUTY_MIN;

volatile uint16 u16StartUpCount = 0;
//IFX_INLINE void Commutation_TimerCtrl(void);

void Motor_startup(void);

sint16 show_commuPoint;
uint8 OLD_PosCtrlStep = 0;
void Commutation_PosCommuCtrl(void)
{
    //if(b_ZeroDetected)
    {
       if((MOTOR_STATE_RUNNING == g_bldc.state)||(MOTOR_STATE_STARTUP == g_bldc.state))
       {
           if(K_ROT_DIR_CCW == g_bldc.rot_dir)
           {
               g_PosCtrlStep = Commutation_getCommuPosIndex(K_ROT_DIR_CCW);
               g_PosCtrlStep += POS_CTRL_STEP_OFFSET_CCW;
               Commutation_Step(g_PosCtrlStep % 6);
           }
           else
           {
               if(K_ROT_DIR_CW == g_bldc.rot_dir)
               {
                   g_PosCtrlStep = Commutation_getCommuPosIndex(K_ROT_DIR_CW);
                   g_PosCtrlStep +=POS_CTRL_STEP_OFFSET_CW;
                   Commutation_Step(g_PosCtrlStep % 6);
               }
           }
       }
    }
}

uint16 REF_Angle_Position;
uint16 Actual_Angle_Position;
void Position_updateDuty(void)
{
    uint16 REF_Pluse_Position;
    float Actual_Pluse_Position;
    /*calculate the position of the motor rotor*/
    if(Encoder_RawPosition>0)
    {
       Actual_Pluse_Position = (float)(Encoder_RawPosition);
    }
    else
    {
       Actual_Pluse_Position = (float)(Encoder_RawPosition+CYCLE_PLUSE);
    }
    Actual_Angle_Position = Actual_Pluse_Position/CYCLE_PLUSE*CYCLE_ANGLE;

    if(g_bldc.loop_mode==LOOP_MODE_POSITION)
    {
        REF_Angle_Position = g_bldc.RefPosition;
        REF_Pluse_Position = (uint16)(REF_Angle_Position/CYCLE_ANGLE*CYCLE_PLUSE);

        if((MOTOR_STATE_STOP == g_bldc.state)||(MOTOR_STATE_STARTUP==g_bldc.state))
        {
            cycle_total = 0;  /*Initial the total cycle*/
        }

        if( (MOTOR_STATE_RUNNING == g_bldc.state||MOTOR_STATE_HOLDING_POSITION == g_bldc.state))
        {
            u8DrvDuty_Positon = Position_Control(REF_Pluse_Position,Encoder_RawPosition);
        }

        if(MOTOR_STATE_HOLDING_POSITION == g_bldc.state)
        {
            HoldingPosition();
        }
    }
}

uint16 REF_Speed;
sint16 var;
sint16 NewREF_Speed=0;
sint16 lastREF_Speed = 0;
static boolean Speed_Enough_To_Start = FALSE;

void SpeedPID_updateDuty(void)
{
    REF_Speed =  g_bldc.Refspeed;
    var = REF_Speed - lastREF_Speed ;
    {(var)=(var)>(100)?(100):(var);(var)=(var)<(-100)?(-100):(var);}
    NewREF_Speed = lastREF_Speed +  var ;
    lastREF_Speed = NewREF_Speed;
    /*the minimum speed limit*/
    if(REF_Speed<280)
    {
        REF_Speed = 0;
        Speed_Enough_To_Start = FALSE;
    }
    else
    {
        Speed_Enough_To_Start = TRUE;
    }

    if( MOTOR_STATE_RUNNING == g_bldc.state)
    {
        u8DrvDuty_Speed = (uint16) VelocityPIDControl(REF_Speed,g_absMotSpeed);//NewREF_Speed
    }

}



#define TORQUE_MODE            (1)
#define DIRECT_CURRENT         (2)
#define CURRENT_GIVEN_MODE     (DIRECT_CURRENT)
float32 REF_Current;
uint16  ref_current;
void Current_updateDuty(void)
{

//   if( MOTOR_STATE_RUNNING == g_bldc.state)
   {
        u8DrvDuty_Current = (uint16) CurrentPIDControl(REF_Current,g_bldc.CurrentV_BUS);
//        u8DrvDuty_Current = 1600;
   }
}


#define UPDATE_DUTY_DELAY_FOLLOW    (1)
#define UPDATE_DUTY_DIRECT          (2)
#define UPDATE_DUTY_MODE            (UPDATE_DUTY_DIRECT)
void updatePWMDutyRunning(void)   /*u8DrvDuty value setting only in this function*/
{
#if(CURRENT_GIVEN_MODE == DIRECT_CURRENT)
    REF_Current =  g_bldc.RefCurrent/10.0;
    ref_current =  g_bldc.RefCurrent;
#elif(CURRENT_GIVEN_MODE == TORQUE_MODE)
    REF_Current = REF_Current_By_Torque;
#endif
    /*choose the motor loop mode while the motor is stopping by the loop_cmd*/
    if(MOTOR_STATE_STOP==g_bldc.state)
    {
        switch(g_bldc.loop_cmd)
        {
            case LOOP_CMD_SPEED:
                g_bldc.loop_mode = LOOP_MODE_SPEED;
                break;

            case LOOP_CMD_CURRENT:
                g_bldc.loop_mode = LOOP_MODE_CURRENT;
                break;

            case LOOP_CMD_DOUBLE_SPPED_CURRENT:
                g_bldc.loop_mode = LOOP_MODE_DOUBLE_SPPED_CURRENT;
                break;

            case LOOP_CMD_POSITION:
                g_bldc.loop_mode = LOOP_MODE_POSITION;
                break;

            default:
                g_bldc.loop_mode = LOOP_MODE_SPEED;
                break;
        }

    }
/*output different Duty at different mode while the motor is running or HoldingPosition*/
    if(MOTOR_STATE_RUNNING == g_bldc.state)
    {

#if(UPDATE_DUTY_MODE == UPDATE_DUTY_DELAY_FOLLOW)
            if(u8DrvDuty >  u8DrvDuty_Current)
            {
                u8DrvDuty--;
            }
            else if(u8DrvDuty <  u8DrvDuty_Current)
            {
                u8DrvDuty+=1;
            }
            else
            {
                /* Change until equal*/
            }
#elif(UPDATE_DUTY_MODE == UPDATE_DUTY_DIRECT)

          switch(g_bldc.loop_mode)
          {
              case LOOP_MODE_SPEED:
                  u8DrvDuty =  u8DrvDuty_Speed;
                  break;

              case LOOP_MODE_CURRENT:
                  u8DrvDuty = u8DrvDuty_Current;
                  break;

              case LOOP_MODE_DOUBLE_SPPED_CURRENT:
                  if(u8DrvDuty_Current>u8DrvDuty_Speed)
                  {
                      u8DrvDuty = u8DrvDuty_Speed;
                  }
                  else
                  {
                      u8DrvDuty = u8DrvDuty_Current;
                  }
                  break;

              case LOOP_MODE_POSITION:
                  u8DrvDuty = u8DrvDuty_Positon;
                  break;

              default:
                  break;
          }

#endif

     }

    /***** Limit check ***************/
       if(u8DrvDuty < K_MOTOR_DRVPWM_DUTY_MIN)
       {
          u8DrvDuty = K_MOTOR_DRVPWM_DUTY_MIN;
       }
       else
       {
           if(u8DrvDuty > g_DutyLimitMax)
           {
              u8DrvDuty = g_DutyLimitMax;
           }
       }

}

void updatePWMDutyStartup(void)
{
 if(g_bldc.loop_mode == LOOP_MODE_CURRENT)
 {
     if(MOTOR_STATE_STARTUP == g_bldc.state)
     {
         u8DrvDuty = u8DrvDuty_Current;
         u16StartUpCount++;
     }
     else
     {
         u16StartUpCount = 0;
     }

 }

 else
 {
    if(Speed_Enough_To_Start!=FALSE)
    {
        if(MOTOR_STATE_STARTUP == g_bldc.state)
        {

            u8DrvDuty = DutyStartupCurve(u16StartUpCount);

            u16StartUpCount++;
        }
        else
        {
            u16StartUpCount = 0;
        }

        /***** Limit check ***************/
        if(u8DrvDuty < K_MOTOR_DRVPWM_DUTY_MIN)
        {
           u8DrvDuty = K_MOTOR_DRVPWM_DUTY_MIN;
        }
        else
        {
            if(u8DrvDuty > g_DutyLimitMax)
            {
               u8DrvDuty = g_DutyLimitMax;
            }
        }
    }
 }
}

void CommutationControl_6StepStart(void)  /* 1ms task*/
{
    if(MOTOR_STATE_STOP == g_bldc.state )
    {
        switch(g_bldc.cmd)
        {
            case MOTOR_CMD_START_CCW:

                g_bldc.state = MOTOR_STATE_STARTUP;
                g_bldc.rot_dir = K_ROT_DIR_CCW;

                break;
            case MOTOR_CMD_START_CW:
                g_bldc.state = MOTOR_STATE_STARTUP;
                g_bldc.rot_dir = K_ROT_DIR_CW;

                break;

            case MOTOR_CMD_REINIT:
                initMultican();
//                appTaskfu_init();
                SPIEncoderInitPosition();
//                initGtmATomPwm_6Step();
                DataFlash_CalibrationInit();
                g_bldc.u32DiagCode = 0;
                break;
            default:
                break;

        }
    }
    else
    {
        if(MOTOR_CMD_STOP == g_bldc.cmd)
        {

            g_bldc.state = MOTOR_STATE_STOP;
            u8DrvDuty = 0;
            CommutationDriver_Stop();
            g_MotStartTimer = 0;

        }


        if(MOTOR_STATE_STARTUP == g_bldc.state )
        {

           if(timeTestTicks)
           {
               timeTestTicks--;
           }
           else
           {
               timeTestTicks = K_CONFIG_DELAY_TIME;

               if(g_MotStartTimer < K_STARTUP_PERIOD)
               {
                     g_MotStartTimer++;
                     Motor_startup();
               }
    /*if motor is at start up state and don't get the 300rpm speed after 10s, it's the start up diagnosis.*/
               else if(g_absMotSpeed<300)
               {
                    g_bldc.state = MOTOR_STATE_FAIL;
                    CommutationDriver_Stop();

                    g_bldc.u32DiagCode |= MOTOR_DIAG_CODE_STARTUP_FAIL;
                    g_MotStartTimer = 0;
               }
           }
        }
        else
        {
            g_MotStartTimer=0;

        }
    }

    if(MOTOR_STATE_FAIL==g_bldc.state)
    {
        CommutationDriver_Stop();
    }
}

#define K_STARTUP_END_SPEED (REF_Speed-50)
void Motor_startup(void)
{
    if( K_ROT_DIR_CCW == g_bldc.rot_dir)
    {
        g_PosCtrlStep =Commutation_getCommuPosIndex(K_ROT_DIR_CCW);

        g_bldc.state = MOTOR_STATE_STARTUP;
        g_bldc.rot_dir = K_ROT_DIR_CCW;

        //if(b_ZeroDetected)
        {
            sint16 absMechSpeed = 0;

            if(g_bldc.RPM_s16MechSpeed > 0)
            {
                absMechSpeed = g_bldc.RPM_s16MechSpeed;
            }
            else
            {
                absMechSpeed =0x00 - (g_bldc.RPM_s16MechSpeed);
            }
            if(g_bldc.loop_mode == LOOP_MODE_CURRENT)
            {
              if(( absMechSpeed > 300)&&(u16StartUpCount >50))
              {
                  g_bldc.state = MOTOR_STATE_RUNNING;
              }
            }
            else
            {
                if(( absMechSpeed > K_STARTUP_END_SPEED)&&(u16StartUpCount >50))
                {
                   g_bldc.state = MOTOR_STATE_RUNNING;
                }
            }

        }
        //else
        //{
            //Commutation_TimerCtrl();
        //}

  }
  else if( K_ROT_DIR_CW == g_bldc.rot_dir )
  {
      g_PosCtrlStep=Commutation_getCommuPosIndex(K_ROT_DIR_CW);

      g_bldc.state = MOTOR_STATE_STARTUP;
      g_bldc.rot_dir = K_ROT_DIR_CW;

      //if(b_ZeroDetected)
      {
          sint16 absMechSpeed = 0;

          if(g_bldc.RPM_s16MechSpeed > 0)
          {
              absMechSpeed = g_bldc.RPM_s16MechSpeed;
          }
          else
          {
              absMechSpeed =0x00 - (g_bldc.RPM_s16MechSpeed);
          }
          if(g_bldc.loop_mode == LOOP_MODE_CURRENT)
          {
            if(( absMechSpeed > 300)&&(u16StartUpCount >50))
            {
                g_bldc.state = MOTOR_STATE_RUNNING;
            }
          }
          else
          {
              if( (absMechSpeed > K_STARTUP_END_SPEED)&&(u16StartUpCount >50))
              {
                 g_bldc.state = MOTOR_STATE_RUNNING;
              }
          }

      }
      //else
      //{
          //Commutation_TimerCtrl();
      //}

  }
  else
  {

  }

}


#if(0)
uint32 g_TimerCtrlStep = 0;
IFX_INLINE void Commutation_TimerCtrl(void)
{
    /* Commutate acc. to timer*/

   if(g_bldc.rot_dir == K_ROT_DIR_CCW)
   {
       g_TimerCtrlStep++;
       if(g_TimerCtrlStep >=6)
       {
          g_TimerCtrlStep=0;
       }

       Commutation_Step(g_TimerCtrlStep % 6);
   }
   else
   {

       g_TimerCtrlStep--;
       if(g_TimerCtrlStep <=0)
       {
          g_TimerCtrlStep=6;
       }

       Commutation_Step(g_TimerCtrlStep % 6);
   }
}
#endif
