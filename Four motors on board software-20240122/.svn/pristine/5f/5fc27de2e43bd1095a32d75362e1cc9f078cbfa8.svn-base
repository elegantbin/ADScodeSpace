/**********************************************************************************************************************
 * \file GTM_ATOM_PWM.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include <GTM_ATOM_PWM_6Step.h>
#include "IfxGtm_Atom_Pwm.h"
#include "IfxPort.h"
#include "CommutationPoint.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ISR_PRIORITY_ATOM  20                                   /* Interrupt priority number                        */
#define WPhase                IfxGtm_ATOM2_1_TOUT43_P23_2_OUT      /* LED which will be driven by the PWM              */
//#define VPhase                IfxGtm_ATOM0_3_TOUT49_P22_2_OUT
#define VPhase                IfxGtm_ATOM2_5_TOUT52_P21_1_OUT
#define UPhase                IfxGtm_ATOM0_2_TOUT46_P23_5_OUT
#define PWM_PERIOD            50                                 /* PWM period for the ATOM                          */
#define CLK_FREQ              1000000.0f                          /* CMU clock frequency, in Hertz                    */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxGtm_Atom_Pwm_Config g_atomConfig[3];                            /* Timer configuration structure                    */
IfxGtm_Atom_Pwm_Driver g_atomDriver[3];                            /* Timer Driver structure                           */

Phase phase;

/*********************************************************************************************************************/
/*-----------------------------------------------Function Prototypes-------------------------------------------------*/
/*********************************************************************************************************************/
IFX_STATIC void setDutyCycle(Phase phase, uint16 dutyCycle);

void CommutationDriver_Stop(void);
/*********************************************************************************************************************/
/*--------------------------------------------Function Implementations-----------------------------------------------*/
/*********************************************************************************************************************/
/* This function initializes the ATOM */
void initGtmATomPwm_6Step(void)
{
    IfxGtm_enable(&MODULE_GTM); /* Enable GTM */

    IfxGtm_Cmu_setClkFrequency(&MODULE_GTM, IfxGtm_Cmu_Clk_0, CLK_FREQ);        /* Set the CMU clock 0 frequency    */
    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_CLK0);                /* Enable the CMU clock 0           */

    //V鐩�
    {
        IfxPort_setPinMode(&MODULE_P22, 0,  IfxPort_Mode_outputPushPullGeneral);//W
        IfxPort_setPinLow(&MODULE_P22, 0);

        IfxGtm_Atom_Pwm_initConfig(&g_atomConfig[V], &MODULE_GTM);

        g_atomConfig[V].atom = VPhase.atom;
        g_atomConfig[V].atomChannel = VPhase.channel;
        g_atomConfig[V].period = PWM_PERIOD;
        g_atomConfig[V].pin.outputPin = &VPhase;
        g_atomConfig[V].dutyCycle = 0;
        g_atomConfig[V].synchronousUpdateEnabled = TRUE;
        IfxGtm_Atom_Pwm_init(&g_atomDriver[V], &g_atomConfig[V]);
        IfxGtm_Atom_Pwm_start(&g_atomDriver[V], TRUE);
    }

    //U鐩�
    {
        IfxPort_setPinMode(&MODULE_P23, 3,  IfxPort_Mode_outputPushPullGeneral);//W
        IfxPort_setPinLow(&MODULE_P23, 3);

        IfxGtm_Atom_Pwm_initConfig(&g_atomConfig[U], &MODULE_GTM);

        g_atomConfig[U].atom = UPhase.atom;
        g_atomConfig[U].atomChannel = UPhase.channel;
        g_atomConfig[U].period = PWM_PERIOD;
        g_atomConfig[U].pin.outputPin = &UPhase;
        g_atomConfig[U].dutyCycle = 0;
        g_atomConfig[U].synchronousUpdateEnabled = TRUE;

        IfxGtm_Atom_Pwm_init(&g_atomDriver[U], &g_atomConfig[U]);

        IfxGtm_Atom_Pwm_start(&g_atomDriver[U], TRUE);
    }

    //W鐩�
    {
        IfxPort_setPinMode(&MODULE_P23, 0,  IfxPort_Mode_outputPushPullGeneral);//W
        IfxPort_setPinLow(&MODULE_P23, 0);

        IfxGtm_Atom_Pwm_initConfig(&g_atomConfig[W], &MODULE_GTM);

        g_atomConfig[W].atom = WPhase.atom;
        g_atomConfig[W].atomChannel = WPhase.channel;
        g_atomConfig[W].period = PWM_PERIOD;
        g_atomConfig[W].pin.outputPin = &WPhase;
        g_atomConfig[W].dutyCycle = 0;
        g_atomConfig[W].synchronousUpdateEnabled = TRUE;

        IfxGtm_Atom_Pwm_init(&g_atomDriver[W], &g_atomConfig[W]);
        IfxGtm_Atom_Pwm_start(&g_atomDriver[W], TRUE);
    }


}

/* This function sets the duty cycle of the PWM */
IFX_STATIC void setDutyCycle(Phase phase, uint16 dutyCycle)
{
    //V U W
    //0 1 2
    g_atomConfig[phase].dutyCycle = dutyCycle * PWM_PERIOD / 1000;                 /* Set duty cycle        */
    IfxGtm_Atom_Pwm_init(&g_atomDriver[phase], &g_atomConfig[phase]); /* Re-initialize the PWM */
}



void CommutationDriver_6Step(uint16 duty, enComutateDriverIndex step)
{
    switch(step){
        case HIGH_V_PWM_LOW_U_ON://V鐩窹WM + U閫�

            setDutyCycle(V,duty);
            setDutyCycle(U,0);
            setDutyCycle(W,0);

            IfxPort_setPinMode(&MODULE_P22, 1,  IfxPort_Mode_outputPushPullGeneral);//V
            IfxPort_setPinLow(&MODULE_P22, 1);
            IfxPort_setPinMode(&MODULE_P22, 3,  IfxPort_Mode_outputPushPullGeneral);//U
            IfxPort_setPinHigh(&MODULE_P22, 3);
            IfxPort_setPinMode(&MODULE_P23, 1,  IfxPort_Mode_outputPushPullGeneral);//W
            IfxPort_setPinLow(&MODULE_P23, 1);

            break;

        case HIGH_V_PWM_LOW_W_ON://V鐩窹WM + W閫�

            setDutyCycle(V,duty);
            setDutyCycle(U,0);
            setDutyCycle(W,0);

            IfxPort_setPinMode(&MODULE_P22, 1,  IfxPort_Mode_outputPushPullGeneral);//V
            IfxPort_setPinLow(&MODULE_P22, 1);
            IfxPort_setPinMode(&MODULE_P22, 3,  IfxPort_Mode_outputPushPullGeneral);//U
            IfxPort_setPinLow(&MODULE_P22, 3);
            IfxPort_setPinMode(&MODULE_P23, 1,  IfxPort_Mode_outputPushPullGeneral);//W
            IfxPort_setPinHigh(&MODULE_P23, 1);

            break;

        case HIGH_U_PWM_LOW_W_ON://U鐩窹WM + W閫�

            setDutyCycle(U,duty);
            setDutyCycle(V,0);
            setDutyCycle(W,0);

            IfxPort_setPinMode(&MODULE_P22, 1,  IfxPort_Mode_outputPushPullGeneral);//V
            IfxPort_setPinLow(&MODULE_P22, 1);
            IfxPort_setPinMode(&MODULE_P22, 3,  IfxPort_Mode_outputPushPullGeneral);//U
            IfxPort_setPinLow(&MODULE_P22, 3);
            IfxPort_setPinMode(&MODULE_P23, 1,  IfxPort_Mode_outputPushPullGeneral);//W
            IfxPort_setPinHigh(&MODULE_P23, 1);

            break;

        case HIGH_U_PWM_LOW_V_ON://U鐩窹WM + V閫�

            setDutyCycle(U,duty);
            setDutyCycle(V,0);
            setDutyCycle(W,0);

            IfxPort_setPinMode(&MODULE_P22, 1,  IfxPort_Mode_outputPushPullGeneral);//V
            IfxPort_setPinHigh(&MODULE_P22, 1);
            IfxPort_setPinMode(&MODULE_P22, 3,  IfxPort_Mode_outputPushPullGeneral);//U
            IfxPort_setPinLow(&MODULE_P22, 3);
            IfxPort_setPinMode(&MODULE_P23, 1,  IfxPort_Mode_outputPushPullGeneral);//W
            IfxPort_setPinLow(&MODULE_P23, 1);

            break;

        case HIGH_W_PWM_LOW_V_ON://W鐩窹WM + V閫�

            setDutyCycle(W,duty);
            setDutyCycle(U,0);
            setDutyCycle(V,0);

            IfxPort_setPinMode(&MODULE_P22, 1,  IfxPort_Mode_outputPushPullGeneral);//V
            IfxPort_setPinHigh(&MODULE_P22, 1);
            IfxPort_setPinMode(&MODULE_P22, 3,  IfxPort_Mode_outputPushPullGeneral);//U
            IfxPort_setPinLow(&MODULE_P22, 3);
            IfxPort_setPinMode(&MODULE_P23, 1,  IfxPort_Mode_outputPushPullGeneral);//W
            IfxPort_setPinLow(&MODULE_P23, 1);

            break;

        case HIGH_W_PWM_LOW_U_ON://W鐩窹WM + U閫�

            setDutyCycle(W,duty);
            setDutyCycle(U,0);
            setDutyCycle(V,0);

            IfxPort_setPinMode(&MODULE_P22, 1,  IfxPort_Mode_outputPushPullGeneral);//V
            IfxPort_setPinLow(&MODULE_P22, 1);
            IfxPort_setPinMode(&MODULE_P22, 3,  IfxPort_Mode_outputPushPullGeneral);//U
            IfxPort_setPinHigh(&MODULE_P22, 3);
            IfxPort_setPinMode(&MODULE_P23, 1,  IfxPort_Mode_outputPushPullGeneral);//W
            IfxPort_setPinLow(&MODULE_P23, 1);

            break;

        default:/* Error status*/
            setDutyCycle(W,0);
            setDutyCycle(U,0);
            setDutyCycle(V,0);

            IfxPort_setPinMode(&MODULE_P22, 1,  IfxPort_Mode_outputPushPullGeneral);//V
            IfxPort_setPinLow(&MODULE_P22, 1);
            IfxPort_setPinMode(&MODULE_P22, 3,  IfxPort_Mode_outputPushPullGeneral);//U
            IfxPort_setPinLow(&MODULE_P22, 3);
            IfxPort_setPinMode(&MODULE_P23, 1,  IfxPort_Mode_outputPushPullGeneral);//W
            IfxPort_setPinLow(&MODULE_P23, 1);
            break;
    }
}


void CommutationDriver_Stop(void)
{

    setDutyCycle(W,0);
    setDutyCycle(U,0);
    setDutyCycle(V,0);
    IfxPort_setPinMode(&MODULE_P22, 1,  IfxPort_Mode_outputPushPullGeneral);//V
    IfxPort_setPinLow(&MODULE_P22, 1);
    IfxPort_setPinMode(&MODULE_P22, 3,  IfxPort_Mode_outputPushPullGeneral);//U
    IfxPort_setPinLow(&MODULE_P22, 3);
    IfxPort_setPinMode(&MODULE_P23, 1,  IfxPort_Mode_outputPushPullGeneral);//W
    IfxPort_setPinLow(&MODULE_P23, 1);

}

