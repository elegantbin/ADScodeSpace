/**********************************************************************************************************************
 * \file GTM_ATOM_PWM.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include <GTM_ATOM_PWM_6Step.h>
#include "IfxGtm_Atom_Pwm.h"
#include "IfxPort.h"
#include "CommutationPoint.h"
#include "CommutationControl.h"
#include "ADC.h"
#include "Duty_control_ADC.h"
#include "MotorMgtSwc.h"
#include <EncoderGpt12.h>
#include"VelocityPI.h"
#include"CurrentPI.h"
#include "dutylimit.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/


/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------Function Prototypes-------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------Function Implementations-----------------------------------------------*/
/*********************************************************************************************************************/

#define K_CONFIG_DELAY_TIME    (5)
#define K_STARTUP_PERIOD        (2000)
uint32 timeTestTicks=K_CONFIG_DELAY_TIME;  /*1ms task*/

uint32 g_MotStartTimer = 0;

uint8  g_PosCtrlStep=0;
uint8 theOld_PosCtrlStep=0;
volatile uint8  b_ZeroDetected =0;
uint16 u8DrvDuty_ref;

uint16 u8DrvDuty = K_MOTOR_DRVPWM_DUTY_MIN;

volatile uint16 u16StartUpCount = 0;
IFX_INLINE void Commutation_TimerCtrl(void);


void Motor_startup(void);

sint16 show_commuPoint;
uint8 OLD_PosCtrlStep = 0;
void Commutation_PosCommuCtrl(void)
{

    //if(b_ZeroDetected)
    {
       if((MOTOR_STATE_RUNNING == g_bldc.state)||(MOTOR_STATE_STARTUP == g_bldc.state))
       {
           if(K_ROT_DIR_CCW == g_bldc.rot_dir)
           {
               g_PosCtrlStep = Commutation_getCommuPosIndex(K_ROT_DIR_CCW);
               g_PosCtrlStep += POS_CTRL_STEP_OFFSET_CCW;
               Commutation_Step(g_PosCtrlStep % 6);
           }
           else
           {
               if(K_ROT_DIR_CW == g_bldc.rot_dir)
               {
                   g_PosCtrlStep = Commutation_getCommuPosIndex(K_ROT_DIR_CW);
                   g_PosCtrlStep +=POS_CTRL_STEP_OFFSET_CW;
                   Commutation_Step(g_PosCtrlStep % 6);
               }
           }
       }
    }
}

uint16 REF_Speed;
void Speed_updateDuty(void)
{
    REF_Speed =  g_bldc.Refspeed/100*100;

    if( MOTOR_STATE_RUNNING == g_bldc.state)
   {

//        REF_Speed = g_Speed_ADC;

        u8DrvDuty_ref = (uint16) VelocityControl(REF_Speed,g_absMotSpeed);
   }
}

uint16 REF_Current;
void Current_updateDuty(void)
{
//    REF_Current =  g_bldc.RefCurrent/100*100;
      REF_Current = 2300;

    if( MOTOR_STATE_RUNNING == g_bldc.state)
   {

//        REF_Speed = g_Speed_ADC;

        u8DrvDuty_ref = (uint16) CurrentControl(REF_Current,g_bldc.CurrentU_BUS);
   }
}


void updatePWMDuty(void)   /*u8DrvDuty value setting only in this function*/
{

    if(MOTOR_STATE_RUNNING == g_bldc.state)
    {
//             u8DrvDuty = u8DrvDuty_ref;

            if(u8DrvDuty >  u8DrvDuty_ref)
            {
                u8DrvDuty--;
            }
            else if(u8DrvDuty <  u8DrvDuty_ref)
            {
                u8DrvDuty+=1;
            }
            else
            {
                /* Change until equal*/
            }
     }

    /***** Limit check ***************/
       if(u8DrvDuty < K_MOTOR_DRVPWM_DUTY_MIN)
       {
          u8DrvDuty = K_MOTOR_DRVPWM_DUTY_MIN;
       }
       else
       {
           if(u8DrvDuty > g_DutyLimitMax)
           {
              u8DrvDuty = g_DutyLimitMax;
           }
       }

}

void updatePWMDutyStartup(void)
{

    if(MOTOR_STATE_STARTUP == g_bldc.state)
    {

        u8DrvDuty = DutyStartupCurve(u16StartUpCount);

        u16StartUpCount++;
    }
    else
    {
        u16StartUpCount = 0;
    }

    /***** Limit check ***************/
    if(u8DrvDuty < K_MOTOR_DRVPWM_DUTY_MIN)
    {
       u8DrvDuty = K_MOTOR_DRVPWM_DUTY_MIN;
    }
    else
    {
        if(u8DrvDuty > g_DutyLimitMax)
        {
           u8DrvDuty = g_DutyLimitMax;
        }
    }
}

void CommutationControl_6StepStart(void)  /* 1ms task*/
{
    if(MOTOR_STATE_STOP == g_bldc.state )
    {
        switch(g_bldc.cmd)
        {
            case MOTOR_CMD_START_CCW:

                g_bldc.state = MOTOR_STATE_STARTUP;
                g_bldc.rot_dir = K_ROT_DIR_CCW;

                break;
            case MOTOR_CMD_START_CW:
                g_bldc.state = MOTOR_STATE_STARTUP;
                g_bldc.rot_dir = K_ROT_DIR_CW;

                break;
            case MOTOR_CMD_DIAG_CLEAR:

                g_bldc.u32DiagCode = 0;
                break;
            default:
                break;

        }
    }
    else
    {
        if(MOTOR_CMD_STOP == g_bldc.cmd)
        {

            g_bldc.state = MOTOR_STATE_STOP;

            CommutationDriver_Stop();
            g_MotStartTimer = 0;

        }


        if(MOTOR_STATE_STARTUP == g_bldc.state )
        {

           if(timeTestTicks)
           {
               timeTestTicks--;
           }
           else
           {
               timeTestTicks = K_CONFIG_DELAY_TIME;

               if(g_MotStartTimer < K_STARTUP_PERIOD)
               {
                     g_MotStartTimer++;
                     Motor_startup();
               }

               else
               {
                    g_bldc.state = MOTOR_STATE_FAIL;
                    CommutationDriver_Stop();


                    g_bldc.u32DiagCode |= MOTOR_DIAG_CODE_STARTUP_FAIL;
                    g_MotStartTimer = 0;
               }
           }
        }
        else
        {
            g_MotStartTimer=0;

        }
    }

    if(MOTOR_STATE_FAIL==g_bldc.state)
    {
        CommutationDriver_Stop();
    }
}

#define K_STARTUP_END_SPEED (REF_Speed)
void Motor_startup(void)
{
    if( K_ROT_DIR_CCW == g_bldc.rot_dir)
    {
        g_PosCtrlStep=Commutation_getCommuPosIndex(K_ROT_DIR_CCW);

        g_bldc.state = MOTOR_STATE_STARTUP;
        g_bldc.rot_dir = K_ROT_DIR_CCW;

        //if(b_ZeroDetected)
        {
            sint16 absMechSpeed = 0;

            if(g_bldc.RPM_s16MechSpeed > 0)
            {
                absMechSpeed = g_bldc.RPM_s16MechSpeed;
            }
            else
            {
                absMechSpeed =0x00 - (g_bldc.RPM_s16MechSpeed);
            }

            if(( absMechSpeed > K_STARTUP_END_SPEED)&&(u16StartUpCount >50))
            {
               g_bldc.state = MOTOR_STATE_RUNNING;
            }

        }
        //else
        //{
            //Commutation_TimerCtrl();
        //}

  }
  else if( K_ROT_DIR_CW == g_bldc.rot_dir )
  {
      g_PosCtrlStep=Commutation_getCommuPosIndex(K_ROT_DIR_CW);

      g_bldc.state = MOTOR_STATE_STARTUP;
      g_bldc.rot_dir = K_ROT_DIR_CW;

      //if(b_ZeroDetected)
      {
          sint16 absMechSpeed = 0;

          if(g_bldc.RPM_s16MechSpeed > 0)
          {
              absMechSpeed = g_bldc.RPM_s16MechSpeed;
          }
          else
          {
              absMechSpeed =0x00 - (g_bldc.RPM_s16MechSpeed);
          }

          if( (absMechSpeed > K_STARTUP_END_SPEED)&&(u16StartUpCount >50))
          {
             g_bldc.state = MOTOR_STATE_RUNNING;
          }

      }
      //else
      //{
          //Commutation_TimerCtrl();
      //}

  }
  else
  {

  }

}

uint32 g_TimerCtrlStep = 0;
IFX_INLINE void Commutation_TimerCtrl(void)
{
    /* Commutate acc. to timer*/

   if(g_bldc.rot_dir == K_ROT_DIR_CCW)
   {
       g_TimerCtrlStep++;
       if(g_TimerCtrlStep >=6)
       {
          g_TimerCtrlStep=0;
       }

       Commutation_Step(g_TimerCtrlStep % 6);
   }
   else
   {

       g_TimerCtrlStep--;
       if(g_TimerCtrlStep <=0)
       {
          g_TimerCtrlStep=6;
       }

       Commutation_Step(g_TimerCtrlStep % 6);
   }
}
