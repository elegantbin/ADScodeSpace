/**********************************************************************************************************************
 * \file ADC_Queued_Scan.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
*/


#include "ADC.h"
#include "MotorMgtSwc.h"
#include "IfxGtm_Tom_Timer.h"
#include <EncoderGpt12.h>
#include "CurrentADC.h"
#include "CommutationControl.h"
#include"Ifxvadc.h"


#define ISR_PRIORITY_TOM    20

/* Interrupt Service Routine of the TOM */
int group_I = 4;
int Chn_I[3] = {3,6,7};
int num_chn;
static uint16 PhaseCurrent[3]={2250,2250,2250};
float SUM_PhaseCurrent[3];
uint16 NEW_current_result[3];
static uint16 OLD_current_result[3] ={2250,2250,2250};

uint8 current_count[3] = {0};


Ifx_VADC_RES conversionResult;

IfxGtm_Tom_Timer g_timerDriver;
IfxGtm_Tom_Timer_Config timerConfig;


IFX_INTERRUPT(interruptGtmTom_currentADC, 2, ISR_PRIORITY_TOM);

void interruptGtmTom_currentADC(void)
{
    IfxPort_setPinMode(&MODULE_P32, 4,  IfxPort_Mode_outputPushPullGeneral);
    IfxPort_togglePin(&MODULE_P32, 4);
    IfxGtm_Tom_Timer_acknowledgeTimerIrq(&g_timerDriver);

    IfxVadc_Adc_startScan(&adcGroup[group_I]);//scan group4
    do{
    conversionResult = IfxVadc_Adc_getResult(&adcChannel[group_I][Chn_I[num_chn]]);
    }while(!conversionResult.B.VF);
    ADC_result[group_I][Chn_I[num_chn]] = conversionResult.B.RESULT;

    IfxVadc_Adc_stopScan(&adcGroup[group_I]);
//    adcGroup[group_current]->group->ASMR.B.LDEV = 0;

    MODULE_GTM.CMU.CLK_EN.U = IFXGTM_CMU_CLKDIS_FXCLK;  /*disable FXCLK*/


    PhaseCurrent_Calculate(num_chn);


    switch(g_PosCtrlStep%6)
    {

           case HIGH_V_PWM_LOW_U_ON:
//               PhaseCurrent[2]  =  PhaseCurrent[num_channel];
//               PhaseCurrent[1]  =  0;
               g_bldc.CurrentU_BUS = PhaseCurrent[0];
               g_bldc.CurrentV_BUS = PhaseCurrent[2];
               g_bldc.CurrentW_BUS = PhaseCurrent[1];


               break;

           case HIGH_V_PWM_LOW_W_ON:
//               PhaseCurrent[2]  =  PhaseCurrent[num_channel];
//               PhaseCurrent[0]  =  268.134;
               g_bldc.CurrentU_BUS = PhaseCurrent[0];
               g_bldc.CurrentV_BUS = PhaseCurrent[2];
               g_bldc.CurrentW_BUS = PhaseCurrent[1];

               break;

           case HIGH_U_PWM_LOW_W_ON:
//               PhaseCurrent[0]  =  PhaseCurrent[num_channel];
//               PhaseCurrent[2]  =  268.723;
               g_bldc.CurrentU_BUS = PhaseCurrent[0];
               g_bldc.CurrentV_BUS = PhaseCurrent[2];
               g_bldc.CurrentW_BUS = PhaseCurrent[1];
               break;

           case HIGH_U_PWM_LOW_V_ON:
//               PhaseCurrent[0]  =  PhaseCurrent[num_channel];
//               PhaseCurrent[1]  =  269.9994;
               g_bldc.CurrentU_BUS = PhaseCurrent[0];
               g_bldc.CurrentV_BUS = PhaseCurrent[2];
               g_bldc.CurrentW_BUS = PhaseCurrent[1];
               break;

           case HIGH_W_PWM_LOW_V_ON:
//               PhaseCurrent[1]  =  PhaseCurrent[num_channel];
//               PhaseCurrent[0]  =  268.134;
               g_bldc.CurrentU_BUS = PhaseCurrent[0];
               g_bldc.CurrentV_BUS = PhaseCurrent[2];
               g_bldc.CurrentW_BUS = PhaseCurrent[1];
               break;

           case HIGH_W_PWM_LOW_U_ON:
//               PhaseCurrent[1]  =  PhaseCurrent[num_channel];
//               PhaseCurrent[2]  =  268.723;
               g_bldc.CurrentU_BUS = PhaseCurrent[0];
               g_bldc.CurrentV_BUS = PhaseCurrent[2];
               g_bldc.CurrentW_BUS = PhaseCurrent[1];
               break;

           default:/* Error status*/

               break;
       }
}

void initGtmTom_currentADC(void)
{
    IfxGtm_enable(&MODULE_GTM);
    IfxGtm_Tom_Timer_initConfig(&timerConfig, &MODULE_GTM);

    timerConfig.base.isrPriority     = ISR_PRIORITY_TOM;
    timerConfig.base.isrProvider     = IfxSrc_Tos_cpu2;
    timerConfig.tom                  = IfxGtm_Tom_1;
    timerConfig.timerChannel         = IfxGtm_Tom_Ch_0;
    timerConfig.clock                = IfxGtm_Tom_Ch_ClkSrc_cmuFxclk2;

    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_FXCLK);
    IfxGtm_Tom_Timer_init(&g_timerDriver, &timerConfig);
}

void initGtmTom_currentADC_Freq(void)
{
    float32 TOM_ADC_FREQ= g_absMotSpeed/0.6;  /* the time of communication is 2/absMotSpeed */
    timerConfig.base.frequency       = TOM_ADC_FREQ;
    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_FXCLK);
    IfxGtm_Tom_Timer_init(&g_timerDriver, &timerConfig);
    IfxGtm_Tom_Timer_run(&g_timerDriver);
}

float Real_PhaseCurrent[3];

#define FilteringMode  (1)
#define NoFiltering      (0)
#define LowPassFiltering (1)
#define AverageFilteringMode1 (2)
#define LowPass_AverageFilteringMode (3)

void PhaseCurrent_Calculate(int nchannel)
{

   // double Factor_DAC = 5.0/4096.0;
   // float Factor_IBUS_phase = 2160.0/22.0;
#if(LowPassFiltering==FilteringMode)
      float beta_current = 0.04;

      NEW_current_result[Chn_I[nchannel]] =
                 beta_current *ADC_result[group_I][Chn_I[nchannel]]+(1-beta_current)*OLD_current_result[Chn_I[nchannel]];

      PhaseCurrent[nchannel]= NEW_current_result[Chn_I[nchannel]];

      OLD_current_result[Chn_I[nchannel]] = NEW_current_result[Chn_I[nchannel]];


#elif(NoFiltering==FilteringMode)
      /*************************original Current**********************/
     PhaseCurrent[nchannel] = ADC_result[group_I][Chn_I[nchannel]];

#elif(AverageFilteringMode1==FilteringMode)
    /*************************average filtering*******************/
   Real_PhaseCurrent[nchannel] =  ADC_result[group_I][Chn_I[nchannel]];
    current_count[nchannel]++;

    if((Real_PhaseCurrent[nchannel] -PhaseCurrent[nchannel] > 100) || (Real_PhaseCurrent[nchannel]-PhaseCurrent[nchannel] < -100))
    {
        Real_PhaseCurrent[nchannel]  = PhaseCurrent[nchannel];
    }

    SUM_PhaseCurrent[nchannel] += Real_PhaseCurrent[nchannel];
    if(current_count[nchannel] == 4)
    {
    PhaseCurrent[nchannel] = SUM_PhaseCurrent[nchannel]/current_count[nchannel];
    current_count[nchannel] = 0;
    SUM_PhaseCurrent[nchannel] =0;
    }
#elif(LowPass_AverageFilteringMode==FilteringMode)
    {

        float beta_current = 0.04;

        NEW_current_result[Chn_I[nchannel]] =
                    beta_current *ADC_result[group_I][Chn_I[nchannel]]+(1-beta_current)*OLD_current_result[Chn_I[nchannel]];

        PhaseCurrent[nchannel]= NEW_current_result[Chn_I[nchannel]];

        OLD_current_result[Chn_I[nchannel]] = NEW_current_result[Chn_I[nchannel]];

        static uint16 current_filter_array[3][10]={{0}};

        uint32 current_sum [3]= {0};
        for(uint8 k=0;k<9;k++)
        {
           current_filter_array[nchannel][k]=current_filter_array[nchannel][k+1];
        }
        current_filter_array[nchannel][9]= PhaseCurrent[nchannel];
//        current_filter_array[nchannel][0]=current_filter_array[nchannel][1];
//        current_filter_array[nchannel][1]=current_filter_array[nchannel][2];
//        current_filter_array[nchannel][2]=current_filter_array[nchannel][3];
//        current_filter_array[nchannel][3]=current_filter_array[nchannel][4];
//        current_filter_array[nchannel][4]=current_filter_array[nchannel][5];
//        current_filter_array[nchannel][5]=current_filter_array[nchannel][6];
//        current_filter_array[nchannel][6]=current_filter_array[nchannel][7];
//        current_filter_array[nchannel][7]=current_filter_array[nchannel][8];
//        current_filter_array[nchannel][8]=current_filter_array[nchannel][9];
//        current_filter_array[nchannel][9]= PhaseCurrent[nchannel];

        for(uint8 i=0;i<10;i++)
        {
            current_sum[nchannel]+=current_filter_array[nchannel][i];
        }
        PhaseCurrent[nchannel] = (uint16)(current_sum[nchannel]/10);
    }
#endif
}


void GtmTomCurrent_6Step(enComutateDriverIndex step)
{
    switch(step){
        case HIGH_V_PWM_LOW_U_ON://V╃WM + U锟
            num_chn = 0;
            initGtmTom_currentADC_Freq();
            break;

        case HIGH_V_PWM_LOW_W_ON://V╃WM + W锟
            num_chn = 1;
            initGtmTom_currentADC_Freq();
            break;

        case HIGH_U_PWM_LOW_W_ON://U╃WM + W锟
            num_chn = 1;
            initGtmTom_currentADC_Freq();

            break;

        case HIGH_U_PWM_LOW_V_ON://U╃WM + V锟
            num_chn = 2;
            initGtmTom_currentADC_Freq();

            break;

        case HIGH_W_PWM_LOW_V_ON://W╃WM + V锟

            num_chn = 2;
            initGtmTom_currentADC_Freq();

            break;

        case HIGH_W_PWM_LOW_U_ON://W╃WM + U锟

            num_chn = 0;
            initGtmTom_currentADC_Freq();

            break;

        default:/* Error status*/

            break;
    }
}

#define offset_detect   (0)
#if(offset_detect)
#define ADC_AMP_OFFSET_TIMES 50             /* 停机状态三相电流的ADC采集次数 */
uint16 adc_amp_offset[3][ADC_AMP_OFFSET_TIMES+1];
uint8 adc_amp_offset_p = 0;
uint16 adc_amp[3];

void CurrentOffesetDetect(void)
{
    double Factor_DAC = 5.0/4096.0;
    float Factor_IBUS_phase = 2160.0/22.0;
  if(g_bldc.state ==  MOTOR_STATE_STOP)
  {

      IfxVadc_Adc_startScan(&adcGroup[group_I]);//scan group4
      int group_current = 4;
      Ifx_VADC_RES conversionResult;
      IfxVadc_Adc_startScan(&adcGroup[group_current]);//scan group4
        for(int k=0;k<3;k++)
        {

          do{
              conversionResult = IfxVadc_Adc_getResult(&adcChannel[group_current][Chn_I[k]]);
            } while( !conversionResult.B.VF );
          ADC_result[group_current][Chn_I[k]] = conversionResult.B.RESULT;
          PhaseCurrent[Chn_I[k]] =
                  ADC_result[group_current][Chn_I[num_chn]]*Factor_IBUS_phase*Factor_DAC;
         }
//    adcGroup[group_current]->group->ASMR.B.LDEV = 0;


              uint8 i;
              uint32 avg[3] = {0,0,0};
              adc_amp_offset[0][adc_amp_offset_p] = PhaseCurrent[0];     /* 获取电机停机状态下的三相电流 */
              adc_amp_offset[1][adc_amp_offset_p] = PhaseCurrent[1];
              adc_amp_offset[2][adc_amp_offset_p] = PhaseCurrent[2];

              adc_amp_offset_p ++;

              if (adc_amp_offset_p >= 50)
              {
                  adc_amp_offset_p = 0;
              }
              for(i=0; i<ADC_AMP_OFFSET_TIMES; i++)
              {
                  avg[0] += adc_amp_offset[0][i];                     /* 各相数值累加 */
                  avg[1] += adc_amp_offset[1][i];
                  avg[2] += adc_amp_offset[2][i];
              }
              for(i=0; i<3; i++)
              {
                  avg[i] /= ADC_AMP_OFFSET_TIMES;                     /* 取平均 */
                  adc_amp_offset[i][ADC_AMP_OFFSET_TIMES] = avg[i];   /* 赋值 */
              }
          }
}
#endif








