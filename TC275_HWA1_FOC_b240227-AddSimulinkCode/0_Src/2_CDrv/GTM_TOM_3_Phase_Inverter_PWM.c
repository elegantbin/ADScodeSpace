
/**********************************************************************************************************************
 * \file GTM_TOM_3_Phase_Inverter_PWM.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxGtm_Tom_PwmHl.h"
#include "IfxCpu_Irq.h"
#include "GTM_TOM_3_Phase_Inverter_PWM.h"
#include "ConfigurationIsr.h"
#include "AppTorqueControl.h"
#include "Vadc_VIT.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define PWM_FREQ_HZ               20000                            /* Define the PWM Switching Frequency value in Hz */
#define PWM_DEAD_TIME             2.0e-6                           /* Define the dead time in s.                     */
#define PWM_MIN_PULSE_TIME        1.0e-6                           /* Define the minimum pulse allowed in s.         */

/* Congfig for 48VBLDC HWA1 */
#define PHASE_U_HS                &IfxGtm_TOM0_10_TOUT46_P23_5_OUT  /* Pin driven by the PWM, P23.5     */
#define PHASE_U_LS                &IfxGtm_TOM0_12_TOUT50_P22_3_OUT  /* Pin driven by the PWM, P22.3    */

#define PHASE_V_HS                &IfxGtm_TOM0_9_TOUT52_P21_1_OUT   /* Pin driven by the PWM, P21.1    */
#define PHASE_V_LS                &IfxGtm_TOM0_8_TOUT48_P22_1_OUT   /* Pin driven by the PWM, P22.1    */

#define PHASE_W_HS                &IfxGtm_TOM0_11_TOUT43_P23_2_OUT  /* Pin driven by the PWM, P23.2  */
#define PHASE_W_LS                &IfxGtm_TOM0_15_TOUT42_P23_1_OUT  /* Pin driven by the PWM, P23.1  */

#define GTM_TOM_MASTER            IfxGtm_Tom_0                      /* Define the timer used                          */
#define GTM_TOM_MASTER_TIMER_CH   IfxGtm_Tom_Ch_0                   /* Define the timer channel used                  */
#define GTM_TOM_TRIG_TIMER_CH_TOUTMAP     &IfxGtm_TOM0_7_TOUT25_P33_3_OUT

#define DUTY_STEP                 0.1                              /* Define duty cycle step                         */
#define DUTY_MIN                  0.1                              /* Define minimum duty cycle (10%)                */
#define DUTY_MAX                  0.98                              /* Define maximum duty cycle (90%)                */


/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
Pwm3PhaseOutput g_pwm3PhaseOutput;

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

/**************************************************************
**** 在A1版本的硬件中。P23.0 是Si_DISABLE_W信号，不能用来作为Test Pin
#define TEST_PIN_INDEX(a)  (a)
#define TEST_PORT_MODULE   (&MODULE_P23)
#define TEST_PIN           TEST_PIN_INDEX(0)
IfxPort_Pin_Config  TestPin=
{
       .port      = TEST_PORT_MODULE,
       .pinIndex  = TEST_PIN,
        .mode      = IfxPort_OutputIdx_general,
        .padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1
};
*******************************************************************/
volatile uint32 count =0;
IFX_INTERRUPT(tom0IsrHandler, 0, INTERRUPT_M0_PWM_TRIGGER)
{
    __enable();
 
    AppVelocity_SpeedUpdate();
    //TorqueControl_FocStep(&g_motor, &g_motor.currents, 0.0);
}

/* This function initializes the TOM */
void initGtmTomPwm(void)
{
    /* Enable the GTM Module */
    IfxGtm_enable(&MODULE_GTM);
    /* Set the GTM global clock frequency in Hz */
    IfxGtm_Cmu_setGclkFrequency(&MODULE_GTM, IfxGtm_Cmu_getModuleFrequency(&MODULE_GTM));
    /* Set the GTM configurable clock frequency in Hz */
    IfxGtm_Cmu_setClkFrequency(&MODULE_GTM, IfxGtm_Cmu_Clk_0, IfxGtm_Cmu_getGclkFrequency(&MODULE_GTM));
    /* Enable the FXU clock                         */
    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_FXCLK);

    IfxGtm_Tom_Timer_Config timerConfig;                                         /* Timer configuration              */
    {
        IfxGtm_Tom_Timer_initConfig(&timerConfig, &MODULE_GTM);                  /* Initialize default parameters    */

        timerConfig.clock= IfxGtm_Tom_Ch_ClkSrc_cmuFxclk0;                       /* Define the CMU clock used        */
        timerConfig.tom = GTM_TOM_MASTER;                                        /* Define the timer used            */
        timerConfig.timerChannel = GTM_TOM_MASTER_TIMER_CH;                      /* Define the channel used          */
        timerConfig.triggerOut = GTM_TOM_TRIG_TIMER_CH_TOUTMAP;

        timerConfig.base.frequency = PWM_FREQ_HZ;                                /* Set timer frequency              */
        timerConfig.base.isrPriority                = 0;//INTERRUPT_M0_PWMHL_PERIOD;
        timerConfig.base.isrProvider                = IfxSrc_Tos_cpu0;
        timerConfig.base.minResolution              = (1.0 / timerConfig.base.frequency) / 1000;
        timerConfig.base.trigger.enabled            = TRUE; //PWM interrupt
        timerConfig.base.trigger.triggerPoint       = 10;
        timerConfig.base.trigger.isrPriority        = INTERRUPT_M0_PWM_TRIGGER;
        timerConfig.base.trigger.isrProvider        = IfxSrc_Tos_cpu0;
        timerConfig.base.trigger.outputMode         = IfxPort_OutputMode_pushPull;
        timerConfig.base.trigger.outputDriver       = IfxPort_PadDriver_cmosAutomotiveSpeed1;
        timerConfig.base.trigger.risingEdgeAtPeriod = TRUE;
        timerConfig.base.trigger.outputEnabled      = TRUE;
        timerConfig.base.countDir                   = IfxStdIf_Timer_CountDir_up;

        IfxGtm_Tom_Timer_init(&g_pwm3PhaseOutput.tmr, &timerConfig);           /* Initialize the TOM               */
    }

    /* Configuration of the PWM channels to control High-side and Low-side power-stages */
    {
        IfxGtm_Tom_PwmHl_Config pwmHlConfig;
        IfxGtm_Tom_ToutMapP ccx[] =
        {
            PHASE_U_HS, /* PWM High-side 1 */
            PHASE_V_HS, /* PWM High-side 2 */
            PHASE_W_HS  /* PWM High-side 3 */
        };
        IfxGtm_Tom_ToutMapP coutx[] =
        {
            PHASE_U_LS, /* PWM Low-side 1 */
            PHASE_V_LS, /* PWM Low-side 2 */
            PHASE_W_LS  /* PWM Low-side 3 */
        };

        /* Initialize the configuration structure to default */
        IfxGtm_Tom_PwmHl_initConfig(&pwmHlConfig);
        /* Calculate the number of PWM channels */
        pwmHlConfig.base.channelCount = sizeof(ccx) / sizeof(IfxGtm_Tom_ToutMapP);
        /* Dead time between the top and bottom channels in seconds */
        pwmHlConfig.base.deadtime = PWM_DEAD_TIME;
        /* Min pulse allowed as active state for the top and bottom PWM in seconds */
        pwmHlConfig.base.minPulse = PWM_MIN_PULSE_TIME;
        /* Set output mode of ccx and coutx pins */
        pwmHlConfig.base.outputMode = IfxPort_OutputMode_pushPull;
        /* Set output pad driver of ccx and coutx pins */
        pwmHlConfig.base.outputDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1;
        /* Set top PWM active state */
        pwmHlConfig.base.ccxActiveState = Ifx_ActiveState_high;
        /* Set bottom PWM active state */
        pwmHlConfig.base.coutxActiveState = Ifx_ActiveState_high;

        pwmHlConfig.ccx   = ccx;                        /* Assign the channels for High-side switches   */
        pwmHlConfig.coutx = coutx;                      /* Assign the channels for Low-side switches    */
        pwmHlConfig.timer = &g_pwm3PhaseOutput.tmr;
        pwmHlConfig.tom   = timerConfig.tom;

        /* Initialize timer object */
        IfxGtm_Tom_PwmHl_init(&g_pwm3PhaseOutput.ch, &pwmHlConfig);
        /* Sets the PWM mode to center aligned */
        IfxGtm_Tom_PwmHl_setMode(&g_pwm3PhaseOutput.ch, Ifx_Pwm_Mode_centerAligned);

        /* Update the input frequency */
        IfxGtm_Tom_Timer_updateInputFrequency(&g_pwm3PhaseOutput.tmr);


    }

    // Set trigger duty cycle to 50 %
//    IfxGtm_Tom_Timer_setTrigger(&g_pwm3PhaseOutput.tmr, IfxGtm_Tom_Timer_getPeriod(&g_pwm3PhaseOutput.tmr)/2);
    IfxGtm_Tom_Timer_setTrigger(&g_pwm3PhaseOutput.tmr, 55);


    /* Calculate initial values of PWM duty cycles */
    g_pwm3PhaseOutput.pwmOnTimes[0] = 0;
    g_pwm3PhaseOutput.pwmOnTimes[1] = 0;
    g_pwm3PhaseOutput.pwmOnTimes[2] = 0;

    /* Update PWM duty cycles */
    IfxGtm_Tom_Timer_disableUpdate(&g_pwm3PhaseOutput.tmr);
    IfxGtm_Tom_PwmHl_setOnTime(&g_pwm3PhaseOutput.ch, g_pwm3PhaseOutput.pwmOnTimes);
    IfxGtm_Tom_Timer_applyUpdate(&g_pwm3PhaseOutput.tmr);


    /* Run the timer */
    IfxGtm_Tom_Timer_run(&g_pwm3PhaseOutput.tmr);

}

/* This function sets the duty cycle of the PWM signals */
void updateGtmTomPwmDutyCycles(void)
{
    Ifx_TimerValue period;
    Ifx_TimerValue dutyStep;
    Ifx_TimerValue dutyStepMin;
    Ifx_TimerValue dutyStepMax;

    /* Get timer period */
    period = g_pwm3PhaseOutput.ch.timer->base.period;
    /* Calculate duty cycle increment */
    dutyStep = period * DUTY_STEP;

    /* Calculate PWM duty cycles limits */
    dutyStepMin = period * DUTY_MIN;
    dutyStepMax = period * DUTY_MAX;

    /* Increment PWM duty cycles */
    g_pwm3PhaseOutput.pwmOnTimes[0] += dutyStep;
    g_pwm3PhaseOutput.pwmOnTimes[1] += dutyStep;
    g_pwm3PhaseOutput.pwmOnTimes[2] += dutyStep;

    /* Limit PWM duty cycles between dutyStepMin and dutyStepMax */
    if(g_pwm3PhaseOutput.pwmOnTimes[0] >= dutyStepMax)
    {
        g_pwm3PhaseOutput.pwmOnTimes[0] = dutyStepMin;
    }
    if(g_pwm3PhaseOutput.pwmOnTimes[1] >= dutyStepMax)
    {
        g_pwm3PhaseOutput.pwmOnTimes[1] = dutyStepMin;
    }
    if(g_pwm3PhaseOutput.pwmOnTimes[2] >= dutyStepMax)
    {
        g_pwm3PhaseOutput.pwmOnTimes[2] = dutyStepMin;
    }

    /* Update new PWM duty cycles */
    IfxGtm_Tom_Timer_disableUpdate(&g_pwm3PhaseOutput.tmr);
    IfxGtm_Tom_PwmHl_setOnTime(&g_pwm3PhaseOutput.ch, g_pwm3PhaseOutput.pwmOnTimes);

    //IfxGtm_Tom_Timer_setTrigger(&g_pwm3PhaseOutput.tmr,g_pwm3PhaseOutput.pwmOnTimes[0]); //TEST
    IfxGtm_Tom_Timer_applyUpdate(&g_pwm3PhaseOutput.tmr);
}



void GTM_Tom_update3ChannelPwm(Pwm3PhaseOutput *pwm, Ifx_TimerValue *tOn, Ifx_TimerValue adcTon)
{
    Ifx_TimerValue period;
    Ifx_TimerValue dutyStepMin;
    Ifx_TimerValue dutyStepMax;

    /* Get timer period */
    period = pwm->ch.timer->base.period;

    /* Calculate PWM duty cycles limits */
    dutyStepMin = period * DUTY_MIN;
    dutyStepMax = period * DUTY_MAX;

    /* Increment PWM duty cycles */
    pwm->pwmOnTimes[0] = tOn[0];
    pwm->pwmOnTimes[1] = tOn[1];
    pwm->pwmOnTimes[2] = tOn[2];

    /* Limit PWM duty cycles between dutyStepMin and dutyStepMax */
    if(pwm->pwmOnTimes[0] >= dutyStepMax)
    {
        pwm->pwmOnTimes[0] = dutyStepMax;
    }
    if(pwm->pwmOnTimes[1] >= dutyStepMax)
    {
        pwm->pwmOnTimes[1] = dutyStepMax;
    }
    if(pwm->pwmOnTimes[2] >= dutyStepMax)
    {
        pwm->pwmOnTimes[2] = dutyStepMax;
    }

    /* Update new PWM duty cycles */
    IfxGtm_Tom_Timer_disableUpdate(&pwm->tmr);
    IfxGtm_Tom_PwmHl_setOnTime(&pwm->ch, &pwm->pwmOnTimes[0]);

    /*Set trigger */
    if(adcTon > 0)
    {
     IfxGtm_Tom_Timer_setTrigger(&pwm->tmr, adcTon);    //adcTon
    }
    else
    {
        //Default Set trigger duty cycle to 50 %
//        IfxGtm_Tom_Timer_setTrigger(&pwm->tmr, IfxGtm_Tom_Timer_getPeriod(&pwm->tmr)/2);
        IfxGtm_Tom_Timer_setTrigger(&pwm->tmr, 5);
    }


    IfxGtm_Tom_Timer_applyUpdate(&pwm->tmr);
}


